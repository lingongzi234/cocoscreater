{"version":3,"sources":["assets/cases/demo/blob/smooth.js"],"names":["getFirstControlPoints","rhs","n","length","x","tmp","b","i","getCubicBezierCurvePoints","points","firstControlPoints","secondControlPoints","size","closed","y","overlap","Math","min","knots","j","f1","f2","ie","je","getCubicBezierCurvePath","module","exports"],"mappings":"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","sourceRoot":"/","sourcesContent":["'use strict';\n\n// smooth helper\nfunction getFirstControlPoints(rhs) {\n    var n = rhs.length,\n        x = [],     // Solution vector.\n        tmp = [],   // Temp workspace.\n        b = 2.0,\n        i;\n\n    x[0] = rhs[0] / b;\n\n    for (i = 1; i < n; i++) { // Decomposition and forward substitution.\n        tmp[i] = 1 / b;\n        b = (i < n - 1 ? 4.0 : 2.0) - tmp[i];\n        x[i] = (rhs[i] - x[i - 1]) / b;\n    }\n\n    for (i = 1; i < n; i++) {\n        x[n - i - 1] -= tmp[n - i] * x[n - i]; // Backsubstitution.\n    }\n    return x;\n}\n\nfunction getCubicBezierCurvePoints(points, firstControlPoints, secondControlPoints) {\n    var size = points.length,\n        closed = points[size-1].x === points[0].x && points[size-1].y === points[0].y,\n        n = size,\n        // Add overlapping ends for averaging handles in closed paths\n        overlap = 0;\n\n    if (closed) {\n        size = n = size-1;\n    }\n\n    if (size <= 2)\n        return;\n    if (closed) {\n        // Overlap up to 4 points since averaging beziers affect the 4\n        // neighboring points\n        overlap = Math.min(size, 4);\n        n += Math.min(size, overlap) * 2;\n    }\n\n    var knots = [];\n    for (var i = 0; i < size; i++)\n        knots[i + overlap] = points[i];\n    if (closed) {\n        // If we're averaging, add the 4 last points again at the\n        // beginning, and the 4 first ones at the end.\n        for (var i = 0; i < overlap; i++) {\n            knots[i] = points[i + size - overlap];\n            knots[i + size + overlap] = points[i];\n        }\n    } else {\n        n--;\n    }\n    // Calculate first Bezier control points\n    // Right hand side vector\n    var rhs = [];\n\n    // Set right hand side X values\n    for (var i = 1; i < n - 1; i++)\n        rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;\n    rhs[0] = knots[0].x + 2 * knots[1].x;\n    rhs[n - 1] = 3 * knots[n - 1].x;\n    // Get first control points X-values\n    var x = getFirstControlPoints(rhs);\n\n    // Set right hand side Y values\n    for (var i = 1; i < n - 1; i++)\n        rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;\n    rhs[0] = knots[0].y + 2 * knots[1].y;\n    rhs[n - 1] = 3 * knots[n - 1].y;\n    // Get first control points Y-values\n    var y = getFirstControlPoints(rhs);\n\n    if (closed) {\n        // Do the actual averaging simply by linearly fading between the\n        // overlapping values.\n        for (var i = 0, j = size; i < overlap; i++, j++) {\n            var f1 = i / overlap,\n                f2 = 1 - f1,\n                ie = i + overlap,\n                je = j + overlap;\n            // Beginning\n            x[j] = x[i] * f1 + x[j] * f2;\n            y[j] = y[i] * f1 + y[j] * f2;\n            // End\n            x[je] = x[ie] * f2 + x[je] * f1;\n            y[je] = y[ie] * f2 + y[je] * f1;\n        }\n        n--;\n    }\n\n    // Now set the calculated handles\n    for (var i = overlap; i <= n - overlap; i++) {\n\n        firstControlPoints[i - overlap] = {\n            x: x[i],\n            y: y[i]\n        };\n\n        if (i < n - 1) {\n            secondControlPoints[i - overlap] = {\n                x: 2 * knots[i + 1].x - x[i + 1],\n                y: 2 * knots[i + 1].y - y[i + 1]\n            };\n        }\n        else {\n            secondControlPoints[i - overlap] = {\n                x: (knots[n].x + x[n - 1]) / 2,\n                y: (knots[n].y + y[n - 1]) / 2\n            };\n        }\n    }\n}\n\nfunction getCubicBezierCurvePath(knots) {\n    var firstControlPoints = [],\n        secondControlPoints = [];\n\n    getCubicBezierCurvePoints(knots, firstControlPoints, secondControlPoints);\n\n    return [firstControlPoints, secondControlPoints];\n}\n\nmodule.exports = getCubicBezierCurvePath;\n"]}